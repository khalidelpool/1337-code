#include "push_swap.h"

stack *parser(int i, int ac, char **av, stack *head)
{
	int j;
	long temp;
	char **numbers;
	int *content;

	while (i < ac)
	{
		numbers = ft_split(av[i], ' ');
		j = 0;
		while (numbers[j])
		{
			temp = ft_atoy(numbers[j]);
			if (temp == 2147483648 || ft_lstcompare(head, (int)temp))
			{
				free_arr(&numbers);
				ft_clearlst(&head);
				return (write(2, "Error\n", 6), NULL);
			}
			ft_add_backlst(&head, ft_newlst((int)temp));
			j++;
		}
		free_arr(&numbers);
		i++;
	}
	return (head);
}

int ft_index_max(stack *head, int choice)
{
	int index;
	int max;
	int i;
	stack *curr;

	curr = head;
	index = 0;
	i = 0;
	max = -2147483648 + choice;
	while (curr != NULL)
	{
		if ((!choice && max <= curr->number) || (choice && max >= curr->number))
		{
			max = curr->number;
			index = i;
		}
		curr = curr->next;
		i++;
	}
	return (index);
}

int ft_target(int number, stack **head_B, int choice)
{
	stack *curr;
	int target;
	int index;
	int biggest;
	int i;
	
	i = 0;
	curr = *head_B;
	index = -1;
	target = -2147483648 + choice;
	while(curr != NULL)
	{
		if ((!choice && number > curr->number && curr->number >= target) || (choice && number < curr->number && curr->number <= target))
		{
			target = curr->number;
			index = i;
		}
		curr = curr->next;
		i++;
	}
	if (index == -1)
		index = ft_index_max(*head_B, choice);
	return (index);
}

int min(int a, int b)
{
	if (a >= b)
		return (b);
	return (a);
}

void ft_move_cheapest(stack **head_A, stack **head_B, int lci_a, int lci_b)
{
	int size_A;
	int size_B;

	size_A = ft_sizelst(*head_A);
	size_B = ft_sizelst(*head_B);
	while (1)
	{
		// you should handle rr and rrr, see garbage.txt
		if (lci_a <= size_A / 2 && lci_a)
			ft_rot(head_A), lci_a--;
		else if (lci_a > size_A / 2 && lci_a != size_A)
			ft_revrot(head_A), lci_a++;
		if (lci_b <= size_B / 2 && lci_b)
			ft_rot(head_B), lci_b--;
		else if (lci_b > size_B / 2 && lci_b != size_B)
			ft_revrot(head_B), lci_b++;
		if ((!lci_a || lci_a == size_A) && (!lci_b || lci_b == size_B))
			break ;
	}
	ft_push(head_A, head_B);
}

void ft_cost(stack **head_A, stack **head_B, int size_A, int size_B, int choice)
{
	long temp_cost;
	long curr_cost;
	stack *curr;
	int temp;
	int i;
	int lci_a; // least cost index of a
	int lci_b; // least cost index of b
	int lci[2];
	int size_A;
	int size_B;

	curr = *head_A;
	i = 0;
	size_A = ft_sizelst(head_A);
	size_B = ft_sizelst(head_B);
	while (curr != NULL)
	{
		temp = ft_target(curr->number, head_B, choice);
		curr_cost = min(i, size_A - i) + min(temp, size_B - temp);
		if (curr == *head_A || curr_cost < temp_cost)
		{
			lci_a = i;
			lci_b = temp;
			temp_cost = curr_cost;
		}
		curr = curr->next;
		i++;
	}
	ft_move_cheapest(head_A, head_B, lci_a, lci_b);
}

int main(int ac, char **av)
{
	stack *head;
	stack *head_b;
	int min;
	int size;

	if (ac < 2)
		return (0);
	head = parser(1, ac, av, (stack *)NULL);

	// pushing 2 elements to B to start the algo
	while (ft_sizelst(head) > 3 && ft_sizelst(head_b) < 2)
		ft_push(&head, &head_b);
	
	// moving least cost element in each iteration
	while (ft_sizelst(head) > 3)
		ft_cost(&head, &head_b, ft_sizelst(head), ft_sizelst(head_b), 0);
	
	ft_sort3(&head);

	// moving least cost element in each iteration
	while (ft_sizelst(head_b))
		ft_cost(&head_b, &head, ft_sizelst(head_b), ft_sizelst(head), -1);
	
	// making sure the smallest number is at the top
	min = ft_index_max(head, -1);
	size = ft_sizelst(head);
	while (1)
	{
		if (min && min <= size / 2)
			ft_rot(&head), min--;
		else if (min != size && min > size / 2)
			ft_revrot(&head), min++;
		else break;
	}
		
	// printing the 2 stacks
	ft_iterlst(head, f);
	printf("------------------------------------\n");
	ft_iterlst(head_b, f);

	ft_clearlst(&head);
	ft_clearlst(&head_b);
}
